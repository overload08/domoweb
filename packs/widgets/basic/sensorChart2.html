<polymer-element name="dmw-basic-sensorChart2" extends="dmw-widget">
    <template>
        <link rel="stylesheet" href="/widget/basic/css/common.css" shim-domshadow>
        <style type="text/css">
            :host {
                height: 100%;
                display: block;
            }
            #spark {
                height: 100%;
            }
            #chart {
                position: absolute;
                bottom: 2%;
                left: 2%;
                width: 96%;
                height: 38%;
                overflow: hidden;
            }
            #thedevicename {
                position: relative;
                white-space: nowrap;
                top: 5%;
                left: 5%;
                overflow: hidden;
                width: 93%;
                font-size: 1.8em;
            }
            #container {
                position: absolute;
                top: 18%;
                left: 5%;
                height: 25%;
                width: 94%;
            }
            #adjusted {
                position: relative;
                display: inline-block;
            }
            #adjusted .unit {
                font-size: 0.8em;
                vertical-align: top;
                height: 100%;
            }
            #minmax {
                position: absolute;
                top: 47%;
                left: 5%;
                overflow: hidden;
                display: inline-block;
                width: 94%;
            }
            #minvalue {
            }
            #maxvalue {
            }
        </style>
        <dmw-sensor id='primary' sensorkey="primary" sensorvalue="{{sensorvalue}}" sensorhistory="{{history}}"></dmw-sensor>
        <shadow></shadow>
        <div id='thedevicename'>{{ devicename }}</div>
        <div id='container'>
          <div id='adjusted'>
              {{number}} <span class="unit">{{unit}}</div>
          </div>
        </div>
        <div id='minmax'>
          <span id='minvalue'>{{min}}</span>&nbsp;<sup><em>min</em></sup>&nbsp;/&nbsp;
          <span id='maxvalue'>{{max}}</span>&nbsp;<sup><em>max</em></sup>
        </div>
        <div id='chart'>
          <div id="spark" class="inlinesparkline">{{spark}}</div>
        </div>
    </template>
    <script src="/widget/basic/js/jquery.sparkline.min.js"></script>
    <script>
        Polymer('dmw-basic-sensorChart2', {
            ready: function() {
                this.super();
                this.devicename = "";
                this.number = "";
                this.unit = "";
                this.currentHistoryValue = [];
            },
            optionsUpdated: function() {
                if (this.options['hideLabels'] == true ) {         
                    this.$.labelprimary.style.visibility = "hidden";
                    this.$.labelsecondary.style.visibility = "hidden";
                }
                else {
                    this.$.labelprimary.style.visibility = "visible";
                    this.$.labelsecondary.style.visibility = "visible";
                }
                this.draw(this.currentHistoryValue);
            },
            sensorsUpdated: function() {
                if (this.$.primary.isSet) {
                    this.devicename = this.$.primary.device['name'];
                    this.labelprimary = this.$.primary.device['name'];
                    this.labelsecondary = this.$.primary.name;
                }
            },
            sensorvalueChanged: function(oldValue, newValue) {
                newValue = newValue.stored_value;
                var unit = this.datatypes[this.$.primary.datatype_id]['unit'];
                if (this.options['autoconvert']==1 && newValue > 0) {
                       var k = 1000;
                       var sizes = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
                       var i = Math.floor(Math.log(newValue) / Math.log(k));
                    this.number = (newValue / Math.pow(k, i)).toPrecision(3);
                    if (unit) {
                        this.unit = sizes[i] + i18n.t("domoweb:unit", { context: this.$.primary.datatype_id, value: unit });
                    }
                } else {
                    this.number = newValue;
                    if (unit) {
                        this.unit = i18n.t("domoweb:unit", { context: this.$.primary.datatype_id, value: unit });
                    }
                }
                this.adjustText(this.$.container, this.$.adjusted);
                this.$.primary.getCurrentDayPerHour();

            },
            historyChanged: function(oldValue, newValue) { 
                // in case the page is not yet nicely loaded...
                if (this.$.spark.clientWidth == 0 || this.$.spark.clientHeight == 0) {
                    setTimeout(function(){
                        this.historyChanged(oldValue, newValue);
                        }.bind(this), 1000);
                }
                else {
                    this.draw(newValue);
                }
            },
            draw: function(newValue) {
                // to allow redraw when options changed
                this.currentHistoryValue = newValue;

                // draw
                var self = this;
                var chartValues = [];
                for(i=0;i<newValue.length;i++) {
                    // 5 because : [ year, month, week, day, hour, value ]
                    chartValues.push(newValue[i][5]);
                }
                // display the chart
                minvalue = Math.min.apply(Math, chartValues).toPrecision(3);
                maxvalue = Math.max.apply(Math, chartValues).toPrecision(3);
 
                // as the graph history is an average, the current value could be lower or bigger than the min/max average value. So we adjust
                current = this.number;
                if (current > maxvalue) {
                    this.max = current;
                }
                else {
                    this.max = maxvalue;
                }
                if (current < minvalue) {
                    this.min = current;
                }
                else {
                    this.min = minvalue;
                }
                //console.log("color:" + this.options['chartColor']);
                //console.log("colornew:" + this.hexToRgbA(this.options['chartColor']));
                $(this.$.spark).sparkline(chartValues, {type: 'line',
                                                        lineColor: this.options['chartColor'],
                                                        fillColor: this.hexToRgbA(this.options['chartColor']),
                                                        spotColor: "",
                                                        minSpotColor: "",
                                                        maxSpotColor: "",
                                                        chartRangeMin: parseFloat(this.options['chartMinValue']),
                                                        chartRangeMax: parseFloat(this.options['chartMaxValue']),
                                                        height: '100%', width: '100%'Â });
                $.sparkline_display_visible();
            },
            adjustText: function(parent, element) {
                var fontsize = window.getComputedStyle(element,null).getPropertyValue("font-size");
                var i = fontsize.substr(0,2);
                //console.log("adjust - " + this.devicename + " / cw = " + parent.clientWidth + ", ch = " + parent.clientHeight);
                if (parent.clientWidth == 0 || parent.clientHeight == 0) {
                    setTimeout(function(){
                        this.adjustText(parent, element);
                        }.bind(this), 1000);
                }
                else {
                    //console.log("adjust - " + this.devicename + " / ew = " + element.clientWidth + ", eh = " + element.clientHeight);
                    if (parent.clientWidth > element.clientWidth && parent.clientHeight > element.clientHeight) {
                        while ( parent.clientWidth > element.clientWidth && parent.clientHeight > element.clientHeight && i < 50){
                            //console.log("adjust - " + this.devicename + " / ew = " + element.clientWidth + ", eh = " + element.clientHeight);
                            element.style.fontSize = i+"px";
                            i++;
                        }
                    } else if (parent.clientWidth < element.clientWidth || parent.clientHeight < element.clientHeight) { // If text is bigger than widget
                        while (parent.clientWidth < element.clientWidth || parent.clientHeight < element.clientHeight){
                            //console.log("adjust - " + this.devicename + " / ew = " + element.clientWidth + ", eh = " + element.clientHeight);
                            element.style.fontSize = i+"px";
                            i--;
                        }
                    }
                }
            },
            hexToRgbA: function(hex){
                // From : https://stackoverflow.com/questions/21646738/convert-hex-to-rgba
                // Add opacity
                var c;
                if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                    c= hex.substring(1).split('');
                    if(c.length== 3){
                        c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c= '0x'+c.join('');
                    return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+',0.3)';
                }
                throw new Error('Bad Hex');
            }
        });
 
    </script>
</polymer-element>
